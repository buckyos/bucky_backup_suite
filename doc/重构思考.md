# 重构思考

## 至上而下
用户关心的是：
产品体验：从备份源到备份目标的备份能完成，备份过程中能有明确的UI感知：预期时间（和速度有关），总IO数
关键性能：备份速度，备份过程中的临时空间使用，备份过程中系统的性能损耗（后台备份，绝不干涉当前电脑的工作），备份完成后所消耗的实际成本（带宽+容量消耗）
生死选择：恢复成功率，恢复速度，恢复后是否会丢失某些数据

功能丰富性上
- 备份源通常是比较固定的：
    指定目录
    软件（系统）集成，这种设计可以让有备份需求的软件与备份服务的提供者分离出来，在软件中提供更便利的备份操作。类似当年各种云盘的开放API
- 能不断支持新的备份目标（服务）（提高数据可靠性）

## 核心架构：备份源和备份目标（服务）的架构，并实现双向的透明扩展
从理想的备份结果来看，一个备份Plan的的核心
    - 成功备份一次，创建一个checkpoint
    - 可以任意选择checkpiont还原。
    - 可以在不还原的情况下，看到已经备份的内容的基本信息
    - 透明加密，让不可信的备份服务的提供者无法看到具体的内容（恢复的时候需要backup suite介入）

仔细研究恢复流程，千万不要陷入“恢复软件要正常工作，需要依赖某些数据正常备份过“的死循环。思考在新设备上安装backup suite的恢复流程
    - 通过默认的备份源找到backup suite的定期备份（每次备份任务完成后，都会建立）
    - 如果找不到备份，则需要尝试手工找到备份，并恢复
      - 备份服务对单个备份文件的支持
    - 恢复backup suite的数据成果后，并重启backup suite
    - 可以看到之前导入的所有备份源，并从源上看到所有的plan和check points
    - 降低了对备份源的最小能力要求，并不需要备份源能准确的list出所有已有的checkpoints。


## 数据恢复的安全与隐私保护
- 存在不可信源上的数据，都通过一个密码保护：
  缺点，该密码是备份时的密码，无法修改，一旦泄露所有备份数据都泄密，忘记则无法恢复数据
- 用非对称加密保存checkpoint的元数据，然后用户只需要持有密钥就能正确恢复数据：
  缺点，一旦密码丢失所有备份丢失(bitslock的惨案),密钥泄露所有备份数据也都泄密
  但在对用户密钥有体系性支持的情况下，安全体系更完整

结论：给用户3个选项，默认选项和备份源有关）
    不加密 （Zone内备份源默认）
    使用密钥加密 （第三方备份源默认）
    使用密码加密（不推荐）

## 扩展性最强的c2c备份
备份源：每个checklist的核心是一个backup item list,每个backup item有一个chunk/chunklist
备份服务：
    - list所有的checkpoint
    - 读取checkpoint
    - 写入checkpoint
    - 写入chunk （不一定需要断点续传）
    - 读取chunk （不一定需要断点续传）


### 备份流程
#### Step1. 准备阶段
- 备份源构造checkpoint:backup item list,每个item相当于一个fileobject，支持chunk/chunklist
- 如需要加密，则构造加密后的列表（加密前和加密后是两个列表） 
- 通过qcid可以加快准备的速度（直接复用之前的结果）

#### Step2. 检查阶段
- 将backup item list发送给backup service
- 根据该checkpoint可以向backup service查询待备份的item列表（可以指定数量）

### Step3. 传输阶段（明确知道需要传输的数据大小
- engine根据item列表，向backup source打开chunk reader,向target打开chunk writer,然后开始copy chunk


### 恢复流程
- 得到checkpoint id,backup service请求backup item list
- backup service返回backup item list
- 根据该列表，向backup service 打开chunk reader,在本地向恢复目标打开chunk writer,开始恢复backup item



## 目录到目录的备份
- 备份源的工作是构造一个待备份的Named Dir Object，checkpoint-id 就是 DirObjectId
  如果是加密则需要
- DirObject可以全展开，得到backup item list,支持备份到 chunk backup service
- 备份源会给待备份的Named Dir Object准备一个“全Link”的Named Mgr,来提高其2次备份cacl named dir object的速度
- 如果拥有极限的性能，自动运行backup_task和restore_task,就能成为同步盘
- 备份服务可以根据DirObject的版本树，提供更丰富的历史记录在线查看功能
- 需要在文件系统显示的备份服务，可以在文件系统中保存备份的最新版本

### 备份流程
不管是backup 还是 restore,核心逻辑都是 需要数据的一方得到了 DirObjId,和获取数据的源信息(url),然后开始
在传输chunk前，先把所有的dirobject下载完成，并构造待下载文件列表，也可以有更好的task管理（将任务转换成backup item list)

#### Step1. 准备阶段
- 备份源cacl named dir object
- 在明确的知道上一个版本的Named Object Dir的id的情况下，可以加快构造速度 
  有需要也可以计算出待备份的文件，并计算待备份数据的大小

#### Step2. 传输阶段
- 将Root Dir Object发送给dir backup service
- dir backup service必须是主动模式的，可以访问backup source 并按需下载

#### Step3. 检查备份
- 向dir backup service查询root dir object id的状态，如果是完全存在则说明下载完成

### 恢复流程
恢复流程基本是上述流程的反向(backup source 和 backup service的逻辑基本对等)

- backup source根据checkpoint的 dir object,结合本地的历史记录，开始尝试恢复目标目录到check point
- 缺少的chunk和object,向backup service请求
- pull的任务化，pull dir/pull chunk在一个named mgr中只有一个，可以查看pull的状态，随时停止一个pull 请求


## Backup engine data model设计Review

### Backup Service(Target)管理
- 每个service instance都有一个url,基本上是  $service_type/$instance_id的模式
- 针对每个instance,都可以单独做一些配置
- Target通常有标准接口，用来查询剩余空间/余额等关键的信息

### Backup Source管理
- 每个source instance,都有一个url,基本上是 $source_type/$instance_id的模式
- 针对每个instance,都可以单独做一些配置

### Plan管理
- 核心是 Source->Target，加密方式
- 通用配置，通常是备份触发的时机
- 一些复杂的调度，是和计费/容量管理有关的

## Backup Item
- 通常是一个最小的“备份/还原”单位，
- 状态为 未开始 / 备份（恢复中）/ 成功（失败）
- *2C 任务中，item通常是一个chunk
- *2D 任务中，item通常是一个file


### Backup Task
- 基于一个Plan，可以创建一个Backup Task
- BackupTask 只有 C2C, C2D,  D2D, D2C 4种类型
- Task提供标准接口，可以查看状态
- Task提供标准接口，可以查询SubItem的状态


### 基于Plan的Checkpoint管理
- 备份成功后，会得到一个checkpoint，但checkpoint本身并不依赖plan的存在而存在。
- 通常以Plan为单位，可以看到所有基于该Plan构造的checkpoint
- 如果Plan删除，也可以选择删除所有相关的checkpoint
- Checkpint本质上是完成的任务，因此其类型也与backup task相同
- c2d,d2d任务，原则上是可以在线查看的


### Restore Task
- 创建RestoreTask的必要条件是CheckPoint和Restore Target URL
- 使用CheckPoint里保存的的原始SourceTargetURL进行恢复，可能会覆盖当前Source的状态
- Restore Target URL可以和Source URL不同，但通常是同一种source url








