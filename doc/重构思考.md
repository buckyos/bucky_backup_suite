# 重构思考

## 至上而下

用户关心的是：
产品体验：从备份源到备份目标的备份能完成，备份过程中能有明确的UI感知：预期时间（和速度有关），总IO数
关键性能：备份速度，备份过程中的临时空间使用，备份过程中系统的性能损耗（后台备份，绝不干涉当前电脑的工作），备份完成后所消耗的实际成本（带宽+容量消耗）
生死选择：恢复成功率，恢复速度，恢复后是否会丢失某些数据

功能丰富性上

- 备份源通常是比较固定的：
  指定目录
  软件（系统）集成，这种设计可以让有备份需求的软件与备份服务的提供者分离出来，在软件中提供更便利的备份操作。类似当年各种云盘的开放API
- 能不断支持新的备份目标（服务）（提高数据可靠性）

## 核心架构：备份源和备份目标（服务）的架构，并实现双向的透明扩展

从理想的备份结果来看，一个备份Plan的的核心
    - 成功备份一次，创建一个checkpoint
    - 可以任意选择checkpiont还原。
    - 可以在不还原的情况下，看到已经备份的内容的基本信息
    - 透明加密，让不可信的备份服务的提供者无法看到具体的内容（恢复的时候需要backup suite介入）

仔细研究恢复流程，千万不要陷入“恢复软件要正常工作，需要依赖某些数据正常备份过“的死循环。思考在新设备上安装backup suite的恢复流程
    - 通过默认的备份源找到backup suite的定期备份（每次备份任务完成后，都会建立）
    - 如果找不到备份，则需要尝试手工找到备份，并恢复
      - 备份服务对单个备份文件的支持
    - 恢复backup suite的数据成果后，并重启backup suite
    - 可以看到之前导入的所有备份源，并从源上看到所有的plan和check points
    - 降低了对备份源的最小能力要求，并不需要备份源能准确的list出所有已有的checkpoints。

## 数据恢复的安全与隐私保护

- 存在不可信源上的数据，都通过一个密码保护：
  缺点，该密码是备份时的密码，无法修改，一旦泄露所有备份数据都泄密，忘记则无法恢复数据
- 用非对称加密保存checkpoint的元数据，然后用户只需要持有密钥就能正确恢复数据：
  缺点，一旦密码丢失所有备份丢失(bitslock的惨案),密钥泄露所有备份数据也都泄密
  但在对用户密钥有体系性支持的情况下，安全体系更完整

结论：给用户3个选项，默认选项和备份源有关）
    不加密 （Zone内备份源默认）
    使用密钥加密 （第三方备份源默认）
    使用密码加密（不推荐）

## 扩展性最强的c2c备份

备份源：每个checklist的核心是一个backup item list,每个backup item有一个chunk/chunklist
备份服务：
    - list所有的checkpoint
    - 读取checkpoint
    - 写入checkpoint
    - 写入chunk （不一定需要断点续传）
    - 读取chunk （不一定需要断点续传）

### 备份流程

#### Step1. 准备阶段

- 备份源构造checkpoint:backup item list,每个item相当于一个fileobject，支持chunk/chunklist
- 如需要加密，则构造加密后的列表（加密前和加密后是两个列表）
- 通过qcid可以加快准备的速度（直接复用之前的结果）

#### Step2. 检查阶段

- 将backup item list发送给backup service
- 根据该checkpoint可以向backup service查询待备份的item列表（可以指定数量）

### Step3. 传输阶段（明确知道需要传输的数据大小

- engine根据item列表，向backup source打开chunk reader,向target打开chunk writer,然后开始copy chunk

### 恢复流程

- 得到checkpoint id,backup service请求backup item list
- backup service返回backup item list
- 根据该列表，向backup service 打开chunk reader,在本地向恢复目标打开chunk writer,开始恢复backup item

## 目录到目录的备份

- 备份源的工作是构造一个待备份的Named Dir Object，checkpoint-id 就是 DirObjectId
  如果是加密则需要
- DirObject可以全展开，得到backup item list,支持备份到 chunk backup service
- 备份源会给待备份的Named Dir Object准备一个“全Link”的Named Mgr,来提高其2次备份cacl named dir object的速度
- 如果拥有极限的性能，自动运行backup_task和restore_task,就能成为同步盘
- 备份服务可以根据DirObject的版本树，提供更丰富的历史记录在线查看功能
- 需要在文件系统显示的备份服务，可以在文件系统中保存备份的最新版本

### 备份流程

不管是backup 还是 restore,核心逻辑都是 需要数据的一方得到了 DirObjId,和获取数据的源信息(url),然后开始
在传输chunk前，先把所有的dirobject下载完成，并构造待下载文件列表，也可以有更好的task管理（将任务转换成backup item list)

#### Step1. 准备阶段

- 备份源cacl named dir object
- 在明确的知道上一个版本的Named Object Dir的id的情况下，可以加快构造速度
  有需要也可以计算出待备份的文件，并计算待备份数据的大小

#### Step2. 传输阶段

- 将Root Dir Object发送给dir backup service
- dir backup service必须是主动模式的，可以访问backup source 并按需下载

#### Step3. 检查备份

- 向dir backup service查询root dir object id的状态，如果是完全存在则说明下载完成

### 恢复流程

恢复流程基本是上述流程的反向(backup source 和 backup service的逻辑基本对等)

- backup source根据checkpoint的 dir object,结合本地的历史记录，开始尝试恢复目标目录到check point
- 缺少的chunk和object,向backup service请求
- pull的任务化，pull dir/pull chunk在一个named mgr中只有一个，可以查看pull的状态，随时停止一个pull 请求

## Backup engine data model设计Review

### Backup Service(Target)管理

- 每个service instance都有一个url,基本上是  $service_type/$instance_id的模式
- 针对每个instance,都可以单独做一些配置
- Target通常有标准接口，用来查询剩余空间/余额等关键的信息

### Backup Source管理

- 每个source instance,都有一个url,基本上是 $source_type/$instance_id的模式
- 针对每个instance,都可以单独做一些配置

### Plan管理

- 核心是 Source->Target，加密方式
- 通用配置，通常是备份触发的时机
- 一些复杂的调度，是和计费/容量管理有关的

## Backup Item

- 通常是一个最小的“备份/还原”单位，
- 状态为 未开始 / 备份（恢复中）/ 成功（失败）
- *2C 任务中，item通常是一个chunk
- *2D 任务中，item通常是一个file

### Backup Task

- 基于一个Plan，可以创建一个Backup Task
- BackupTask 只有 C2C, C2D,  D2D, D2C 4种类型
- Task提供标准接口，可以查看状态
- Task提供标准接口，可以查询SubItem的状态

### 基于Plan的Checkpoint管理

- 备份成功后，会得到一个checkpoint，但checkpoint本身并不依赖plan的存在而存在。
- 通常以Plan为单位，可以看到所有基于该Plan构造的checkpoint
- 如果Plan删除，也可以选择删除所有相关的checkpoint
- Checkpint本质上是完成的任务，因此其类型也与backup task相同
- c2d,d2d任务，原则上是可以在线查看的

### Restore Task

- 创建RestoreTask的必要条件是CheckPoint和Restore Target URL
- 使用CheckPoint里保存的的原始SourceTargetURL进行恢复，可能会覆盖当前Source的状态
- Restore Target URL可以和Source URL不同，但通常是同一种source url

## 核心流程简化

Chunk Backup Service的核心是实现起来最简单，兼容性最广的
Chunk Backup Service一定是被动的，因此一定有OpenChunkWriter,CompleteChunkWriter的环节。
Chunk Backup Service可以查询状态（基于checkpoint和基于item key 查询）

一些常见问题：

- 性能问题:支持rhttp 的server,如何变成主动模式？
- 如何将小文件打包成一个大的Item?

### C2C 加密备份

- 准备阶段 (纯本地流程)
  - 创建待备份的checkpoint对象，得到本次的密钥
  - 扫描得到待备份的本地的BackupItem列表，本地bakcupitem里包含原始chunkid和加密后的chunkid(不需要额外空间)

```
backup_item_list = source.prepare_check_point(source_url,backup_config,(action)=>{
  if action == item_ok(file_name,file_size)
    total_file ++
    total_file_size += file_size
    task_db.update(prepare_task_id,total_file,total_file_size)
})
check_point.org_backup_item_list_id = backup_item_list.gen_id()
if backup_config.enable_protect:
  remote_backup_item_list = gen_remote_item_list()
  check_pint.backup_item_list_id = remote_backup_item_list
else:
  check_point.backup_item_list_id = org_backup_item_list_id

check_point.state = LOCAL_OK


```

- 在target上创建有效checkpint
  - 发送checkpoint对象给backup service（checkpint里的backup itemlist不包含加密前的chunkid)
  - 等待服务器返回checkpint进入可传输阶段，才进入下一个阶段。
  - 有的服务器支持主动模式，未进入传输阶段也可以看到服务器完成了chunk.

```
result = target.alloc_check_pint(check_point)
if result.ok() {
  //work thread,check states
  loop {
    remote_check_point_state = target.query_check_point_state(result.check_point_id)
    engine_update_task_state(remote_check_piont_state)
    engine_update_backup_item_state(remote_check_point_state)
    match result.remote_check_point_state.state {
      NEED_ITEM_LIST =>
        target.put_object(check_point.backup_item_list_id,backpu_item_list)
      WAIT=>
        sleep(remote_check_piont_state.wait_time)
      TRANS =>
        items = engine.get_not_complete_items()
        for item in items:
          writer = target.open(item)
          if writer.is_complete()
            contine;
          reader = source.open(item)
          copy(reader,writer)
          engein.mark_item_complete(item)
       
    }

  }
}
```

- 传输阶段

  - 可以随时向backup service查询,checpoint的状态（哪些backup item是就绪的）
  - 基于item key打开writer时，会明确的知道item的状态
  - 使用copy(source.open_readr,target.open_writer)完成item的备份
- 完成阶段
  source从自己的状态机角度，已经看到所有的backup chunk item都传输完成了，则进入该阶段
  source最后向target查询:在target看来，checkpoint的状态是已经完成 （所有的bakcup item是否都已经完成？）
  如果target返回未完成，则需返回未完成的backup item list,基于该list修改本地状态后，再次进入传输阶段。

```
source.create_check_point(config,check_point_id)
source.query_check_point(check_point_id)
backup_items = source.get_check_point_items(check_point_id)

target.create_check_point(check_point_id,backup_items)


```

### C2C 加密恢复

- 得到checkpiont(如果是从远端恢复的，还需要用密钥恢复本地chunkid，和解密密钥）
- 根据checkpoint的backup item list,查询恢复目的地的item状态

```
backup_item_list = target.get_and_verify_item_list(checkpint.item_list_id)
org_backup_item_list = checkpiont.process(backup_item_list)

```

- 持续完成未恢复的bakcup item

```
for item in org_backup_item_list:
  raw_reader = BackupTarget.open_reader(checkpoint_id,,item.item_id,item.chunk_id)
  reader = AesStream.open(chekpoint.aes_key,raw_reader)
  writer = BackupSource.open_writer_for_restore(restor_url,item.item_id)
  copy(reader,writer)
  BackupSource.complete(restore_url,item_key)
```
